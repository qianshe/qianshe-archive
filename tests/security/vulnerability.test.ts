/**
 * 安全漏洞扫描测试
 * 测试常见的安全漏洞和防护措施
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';

// 安全测试工具类
class SecurityTester {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  async testXSS(
    endpoint: string,
    payload: string
  ): Promise<{ vulnerable: boolean; response?: Response }> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: payload,
          title: payload,
          comment: payload
        })
      });

      const responseText = await response.text();
      const vulnerable = responseText.includes(payload) && !responseText.includes('&#');

      return { vulnerable, response };
    } catch (_error) {
      return { vulnerable: false };
    }
  }

  async testSQLInjection(
    endpoint: string,
    payload: string
  ): Promise<{ vulnerable: boolean; response?: Response }> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}?id=${encodeURIComponent(payload)}`, {
        method: 'GET'
      });

      const responseText = await response.text();
      const sqlErrorPatterns = [
        /SQL syntax/i,
        /mysql_fetch/i,
        /ORA-[0-9]{5}/i,
        /Microsoft ODBC/i,
        /SQLite\.JDBC/i,
        /PostgreSQL query failed/i,
        /Warning.*mysql_/i,
        /valid PostgreSQL result/i,
        /Npgsql\\./i,
        /PG::SyntaxError/i,
        /org\.postgresql\.util\.PSQLException/i,
        /ERROR: parser: parse error/i
      ];

      const vulnerable = sqlErrorPatterns.some(pattern => pattern.test(responseText));

      return { vulnerable, response };
    } catch (_error) {
      return { vulnerable: false };
    }
  }

  async testCSRF(
    endpoint: string,
    origin?: string
  ): Promise<{ vulnerable: boolean; response?: Response }> {
    try {
      const headers: Record<string, string> = {
        'Content-Type': 'application/json'
      };

      if (origin) {
        headers['Origin'] = origin;
        headers['Referer'] = origin;
      }

      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          action: 'delete',
          id: 1
        })
      });

      // 检查是否有CSRF保护
      const csrfTokenHeaders = ['x-csrf-token', 'x-xsrf-token', 'csrf-token', 'x-requested-with'];

      const hasCSRFProtection = csrfTokenHeaders.some(
        header => response.headers.get(header) || response.headers.get(`x-${header}`)
      );

      // 如果没有CSRF保护且请求成功，可能存在漏洞
      const vulnerable = !hasCSRFProtection && response.ok;

      return { vulnerable, response };
    } catch (_error) {
      return { vulnerable: false };
    }
  }

  async testAuthenticationBypass(
    endpoint: string
  ): Promise<{ vulnerable: boolean; response?: Response }> {
    try {
      // 测试未认证访问
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'GET',
        headers: {
          Authorization: 'Bearer invalid-token'
        }
      });

      // 如果应该需要认证但请求成功，可能存在认证绕过
      const vulnerable = response.ok && response.status !== 401 && response.status !== 403;

      return { vulnerable, response };
    } catch (_error) {
      return { vulnerable: false };
    }
  }

  async testRateLimiting(
    endpoint: string,
    requests: number = 50
  ): Promise<{ vulnerable: boolean; blockedRequests: number }> {
    let blockedRequests = 0;

    for (let i = 0; i < requests; i++) {
      try {
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
          method: 'GET'
        });

        if (response.status === 429 || response.status === 503) {
          blockedRequests++;
        }
      } catch (_error) {
        blockedRequests++;
      }
    }

    // 如果没有任何请求被阻止，可能存在限流漏洞
    const vulnerable = blockedRequests === 0;

    return { vulnerable, blockedRequests };
  }

  async testInformationDisclosure(
    endpoint: string
  ): Promise<{ vulnerable: boolean; disclosedInfo: string[] }> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method: 'GET',
        headers: {
          Accept: 'text/html,application/json,text/plain,*/*'
        }
      });

      const responseText = await response.text();
      const disclosedInfo: string[] = [];

      // 检查敏感信息泄露
      const sensitivePatterns = [
        { pattern: /password/i, type: 'password' },
        { pattern: /secret/i, type: 'secret' },
        { pattern: /token/i, type: 'token' },
        { pattern: /api[_-]?key/i, type: 'api_key' },
        { pattern: /database/i, type: 'database_info' },
        { pattern: /internal/i, type: 'internal_info' },
        { pattern: /stack trace/i, type: 'stack_trace' },
        { pattern: /error.*mysql/i, type: 'database_error' },
        { pattern: /\/var\/www\//i, type: 'file_path' },
        { pattern: /C:\\\\www\\\\/i, type: 'windows_path' }
      ];

      sensitivePatterns.forEach(({ pattern, type }) => {
        if (pattern.test(responseText)) {
          disclosedInfo.push(type);
        }
      });

      // 检查响应头中的敏感信息
      const serverHeader = response.headers.get('server');
      const poweredByHeader = response.headers.get('x-powered-by');

      if (serverHeader) {
        disclosedInfo.push(`server: ${serverHeader}`);
      }

      if (poweredByHeader) {
        disclosedInfo.push(`powered_by: ${poweredByHeader}`);
      }

      const vulnerable = disclosedInfo.length > 0;

      return { vulnerable, disclosedInfo };
    } catch (_error) {
      return { vulnerable: false, disclosedInfo: [] };
    }
  }
}

describe('安全漏洞扫描测试', () => {
  const portfolioUrl = process.env.TEST_PORTFOLIO_URL || 'http://localhost:8787';
  const dashboardUrl = process.env.TEST_DASHBOARD_URL || 'http://localhost:8788';

  const portfolioSecurity = new SecurityTester(portfolioUrl);
  const dashboardSecurity = new SecurityTester(dashboardUrl);

  beforeAll(() => {
    console.info('开始安全漏洞扫描测试...');
    console.info(`Portfolio URL: ${portfolioUrl}`);
    console.info(`Dashboard URL: ${dashboardUrl}`);
  });

  describe('XSS (跨站脚本攻击) 防护测试', () => {
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      'javascript:alert("XSS")',
      '<svg onload=alert("XSS")>',
      '"><script>alert("XSS")</script>',
      '\"><script>alert(\"XSS\")</script>',
      '<iframe src="javascript:alert(`XSS`)"></iframe>',
      '<body onload=alert("XSS")>',
      '<input autofocus onfocus=alert("XSS")>',
      '<select onfocus=alert("XSS") autofocus>'
    ];

    it('Portfolio 应该防护 XSS 攻击', async () => {
      const vulnerabilities: string[] = [];

      for (const payload of xssPayloads) {
        const result = await portfolioSecurity.testXSS('/api/comments', payload);
        if (result.vulnerable) {
          vulnerabilities.push(payload);
        }
      }

      console.info('Portfolio XSS 测试结果:', {
        测试载荷数: xssPayloads.length,
        漏洞数量: vulnerabilities.length,
        漏洞载荷: vulnerabilities
      });

      expect(vulnerabilities.length).toBe(0);
    });

    it('Dashboard 应该防护 XSS 攻击', async () => {
      const vulnerabilities: string[] = [];

      for (const payload of xssPayloads) {
        const result = await dashboardSecurity.testXSS('/api/posts', payload);
        if (result.vulnerable) {
          vulnerabilities.push(payload);
        }
      }

      console.info('Dashboard XSS 测试结果:', {
        测试载荷数: xssPayloads.length,
        漏洞数量: vulnerabilities.length
      });

      expect(vulnerabilities.length).toBe(0);
    });
  });

  describe('SQL 注入防护测试', () => {
    const sqlPayloads = [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "' OR '1'='1' /*",
      "admin'--",
      "admin' /*",
      "' OR 1=1--",
      "' OR 1=1#",
      "' OR 1=1/*",
      "') OR '1'='1--",
      "') OR ('1'='1--",
      "'; DROP TABLE users; --",
      "'; INSERT INTO users VALUES('hacker','password'); --",
      "' UNION SELECT * FROM users--",
      "' UNION SELECT schema_name FROM information_schema.schemata--"
    ];

    it('Portfolio 应该防护 SQL 注入', async () => {
      const vulnerabilities: string[] = [];

      for (const payload of sqlPayloads) {
        const result = await portfolioSecurity.testSQLInjection('/api/posts', payload);
        if (result.vulnerable) {
          vulnerabilities.push(payload);
        }
      }

      console.info('Portfolio SQL注入测试结果:', {
        测试载荷数: sqlPayloads.length,
        漏洞数量: vulnerabilities.length
      });

      expect(vulnerabilities.length).toBe(0);
    });

    it('Dashboard 应该防护 SQL 注入', async () => {
      const vulnerabilities: string[] = [];

      for (const payload of sqlPayloads) {
        const result = await dashboardSecurity.testSQLInjection('/api/posts', payload);
        if (result.vulnerable) {
          vulnerabilities.push(payload);
        }
      }

      console.info('Dashboard SQL注入测试结果:', {
        测试载荷数: sqlPayloads.length,
        漏洞数量: vulnerabilities.length
      });

      expect(vulnerabilities.length).toBe(0);
    });
  });

  describe('CSRF (跨站请求伪造) 防护测试', () => {
    it('Dashboard 应该有 CSRF 防护', async () => {
      const maliciousOrigins = [
        'https://evil.com',
        'http://malicious-site.net',
        'https://phishing.site'
      ];

      let vulnerabilities = 0;

      for (const origin of maliciousOrigins) {
        const result = await dashboardSecurity.testCSRF('/api/posts', origin);
        if (result.vulnerable) {
          vulnerabilities++;
        }
      }

      console.info('CSRF 防护测试结果:', {
        测试来源数: maliciousOrigins.length,
        漏洞数量: vulnerabilities
      });

      // 允许少量CSRF测试失败（取决于具体实现）
      expect(vulnerabilities).toBeLessThan(maliciousOrigins.length);
    });
  });

  describe('认证和授权测试', () => {
    it('Dashboard 管理接口应该需要认证', async () => {
      const protectedEndpoints = [
        '/api/posts',
        '/api/projects',
        '/api/settings',
        '/api/analytics',
        '/api/users'
      ];

      let vulnerabilities = 0;

      for (const endpoint of protectedEndpoints) {
        const result = await dashboardSecurity.testAuthenticationBypass(endpoint);
        if (result.vulnerable) {
          vulnerabilities++;
        }
      }

      console.info('认证测试结果:', {
        测试端点数: protectedEndpoints.length,
        认证绕过漏洞数: vulnerabilities
      });

      expect(vulnerabilities).toBe(0);
    });

    it('应该有适当的权限控制', async () => {
      // 测试不同权限级别的访问控制
      const testCases = [
        { endpoint: '/api/admin/users', shouldFail: true },
        { endpoint: '/api/settings/system', shouldFail: true },
        { endpoint: '/api/posts', shouldFail: false } // 普通用户可能可以访问
      ];

      let vulnerabilities = 0;

      for (const { endpoint, shouldFail } of testCases) {
        try {
          const response = await fetch(`${dashboardUrl}${endpoint}`, {
            method: 'GET',
            headers: {
              Authorization: 'Bearer regular-user-token'
            }
          });

          const isVulnerable = shouldFail ? response.ok : !response.ok;
          if (isVulnerable) {
            vulnerabilities++;
          }
        } catch (_error) {
          // 连接失败不算安全漏洞
        }
      }

      console.info('权限控制测试结果:', {
        测试用例数: testCases.length,
        权限控制漏洞数: vulnerabilities
      });

      expect(vulnerabilities).toBeLessThan(2); // 允许少量测试失败
    });
  });

  describe('速率限制测试', () => {
    it('应该有适当的速率限制', async () => {
      const testEndpoints = ['/api/auth/login', '/api/comments', '/api/contact'];

      let totalVulnerabilities = 0;

      for (const endpoint of testEndpoints) {
        const result = await portfolioSecurity.testRateLimiting(endpoint, 30);
        if (result.vulnerable) {
          totalVulnerabilities++;
        }

        console.info(`速率限制测试 ${endpoint}:`, {
          总请求数: 30,
          被阻止请求数: result.blockedRequests,
          有漏洞: result.vulnerable
        });
      }

      console.info('速率限制总体测试结果:', {
        测试端点数: testEndpoints.length,
        漏洞端点数: totalVulnerabilities
      });

      // 允许部分端点没有速率限制
      expect(totalVulnerabilities).toBeLessThan(testEndpoints.length);
    });
  });

  describe('信息泄露测试', () => {
    it('不应该泄露敏感信息', async () => {
      const testEndpoints = ['/', '/api/posts', '/api/nonexistent', '/error', '/debug'];

      const totalDisclosedInfo: string[] = [];

      for (const endpoint of testEndpoints) {
        const result = await portfolioSecurity.testInformationDisclosure(endpoint);
        if (result.vulnerable) {
          totalDisclosedInfo.push(...result.disclosedInfo);
        }
      }

      // 去重
      const uniqueDisclosedInfo = [...new Set(totalDisclosedInfo)];

      console.info('信息泄露测试结果:', {
        测试端点数: testEndpoints.length,
        泄露信息类型: uniqueDisclosedInfo
      });

      // 允许泄露一些非敏感信息（如服务器类型）
      const nonSensitiveInfo = ['server:', 'powered_by:'];
      const sensitiveDisclosures = uniqueDisclosedInfo.filter(
        info => !nonSensitiveInfo.some(nonSensitive => info.includes(nonSensitive))
      );

      expect(sensitiveDisclosures.length).toBeLessThan(3);
    });
  });

  describe('HTTPS 和安全头测试', () => {
    it('应该设置适当的安全头', async () => {
      const testEndpoints = ['/', '/api/posts'];

      for (const endpoint of testEndpoints) {
        try {
          const response = await fetch(`${portfolioUrl}${endpoint}`, {
            method: 'GET'
          });

          const securityHeaders = {
            'x-content-type-options': response.headers.get('x-content-type-options'),
            'x-frame-options': response.headers.get('x-frame-options'),
            'x-xss-protection': response.headers.get('x-xss-protection'),
            'strict-transport-security': response.headers.get('strict-transport-security'),
            'content-security-policy': response.headers.get('content-security-policy'),
            'referrer-policy': response.headers.get('referrer-policy')
          };

          console.info(`安全头检查 ${endpoint}:`, securityHeaders);

          // 检查关键安全头
          expect(securityHeaders['x-content-type-options']).toBe('nosniff');
          expect(securityHeaders['x-frame-options']).toBeTruthy();
        } catch (_error) {
          console.warn(`无法检查端点 ${endpoint} 的安全头:`, error);
        }
      }
    });
  });

  describe('输入验证测试', () => {
    it('应该正确处理恶意输入', async () => {
      const maliciousInputs = [
        { field: 'email', value: '../../../etc/passwd' },
        { field: 'id', value: '999999999999999999999' },
        { field: 'limit', value: '-1' },
        { field: 'page', value: 'abc' },
        { field: 'search', value: '../../' }
      ];

      let vulnerabilities = 0;

      for (const { field, value } of maliciousInputs) {
        try {
          const response = await fetch(
            `${portfolioUrl}/api/posts?${field}=${encodeURIComponent(value)}`,
            {
              method: 'GET'
            }
          );

          // 如果服务器返回500错误，可能存在输入验证漏洞
          if (response.status === 500) {
            vulnerabilities++;
          }
        } catch (_error) {
          // 网络错误不算安全漏洞
        }
      }

      console.info('输入验证测试结果:', {
        测试用例数: maliciousInputs.length,
        漏洞数量: vulnerabilities
      });

      expect(vulnerabilities).toBeLessThan(2); // 允许少量测试失败
    });
  });

  afterAll(() => {
    console.info('安全漏洞扫描测试完成');
    console.info('注意: 这些测试仅用于基本安全检查，生产环境建议使用专业安全扫描工具');
  });
});
